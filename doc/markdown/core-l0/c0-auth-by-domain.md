---
title: 采用域用户登录系统
author: zozohtnt@gmail.com
key: c0-abd
---

--------------------------------------
# 动机：为什么要采用域用户登录系统

有时候用户创建了一个域后，想协同多个账户处理本域的内容。譬如公司的内部管理系统。
如果每个用户都建立系统账户，有下面的缺点：

- 域用户需要的权限太大
- 建立的组织内账户不够私密

所以我们需要一套域内的私有账户体系。

--------------------------------------
# 计划应用场景

- 企业信息化工具的内部私有账户体系
- 域的官网与后台的统一登录场景

--------------------------------------
# 设计思路与边界

基于[基础账户授权模型][c0-bam]，只需要让域站点用户可以建立系统级的会话即可。

 Path                        | 接口描述
-----------------------------|-----------------------
 auth_login_by_domain_ticket | 域站点会话票据自动创建系统会话
 auth_login_by_domain_passwd | 域站点用户密码创建系统会话

> 票据的获取方式，请参看: [站点账户授权接口][w0-saa]

- 域站点登录，当用户退出时，需要通过元数据 `QUIT` 指明退出的URL
- 登录时，如果指定了站点 ID 就采用，否则将根据`host`自动寻找站点

--------------------------------------
# 根据`host`寻找域站点

如果不指明域站点，这里要特别说明一下如何根据 `host` 找到站点
首先根据请求带的 `host` 可以从 `/domain` 的映射表里得到对应的域。

但是一个域是否可以混合登录，混合登录用的域账户库在哪里呢？

我们规定了一个元数据 `auth_site`，它指向一个域内的站点目录，
从站点目录的元数据就能找到账户库了。

```bash
#--------------------------------------------
# 映射表里存放域名->域目录的映射
/domain
|-- your.domain.com{dmn:"demo"}   # 域名映射
#--------------------------------------------
# 域目录存放站点目录映射
/home/demo        # auth_site:"~/www" 指明混合登录账户库
  |-- www/        # accounts:"~/accounts" 指明账户库
  |-- accounts/   # 账户库
```

--------------------------------------
# 关于域登录设置的特别说明

## 环境变量

域账号登录后，初始环境变量是在 `~/www/website` （即站点目录）的元数据中指定的。
譬如，其典型的设置：

```js
{
  accounts : "~/accounts",
  roles    : "~/roles",
  organizition : "~/.domain/organization.json"
  env : {
    "!HOME"  : "/home/${domain}/",
    "THEME" : "deep-blue",
    "SKY_COLORIZED" : true,
    "PATH"  : "/bin:/sbin:~/bin",
    "OPEN"  : "wn.manager",
    "APP_PATH"  : "/rs/ti/app:/app",
    "QUIT"      : "/a/login",
    "VIEW_PATH" : "/mnt/project/${domain}/view/:/rs/ti/view/",
    "SIDEBAR_PATH" : "~/.ti/sidebar-crystal.json",
    "ENABLE_CONSOLE" : "yes"
  },
  se_dft_du : 86400,
  se_tmp_du : 60
}
```

**!!注意!!**, 通常这个 "!HOME" 要设置正确，否则 `ti sidebar` 或者 `ti pvg` 等命令，会读取到其他主目录，会抛权限不足的错误。

这里的 "!HOME" 表示强制设置，其他不带 "!" 开始的环境变量，则为默认值。

> 详细请参看[站点模型][w0-site]

## 组和权限

在域的账号数据集(`~/accounts`)中，可以指定特殊元数据:

- `roleInDomain` 在域主组中的系统角色，默认是`GUEST`
- `roleInOp` 在系统`op`组中的系统角色，默认是`GUEST`

同时，在域角色数据集(`~/roles`)中，可以指定这两元数据，作为账户的默认值

## 其他角色

在账户系统中，有一个固定的角色名为 `others`，这个角色的权限是在域登录后固定加载的。
当然，前提是你需要在域角色数据集(`~/roles`)中声明它。

这样，定制权限的时候，可以用 `@others` 指定一个对象的默认访问权限。
因为**所有人**都是**其他人**

## 按照组织架构设置权限

一个多用户的系统，除了按照`用户/角色`设定权限外，还有一个很常见的要求是按照组织结构设置权限。
因此，我们需要:

1. 定义组织结构
2. 每个用户都可以选择自己所在组织节点（可多选）
3. 数据对象可以设置自己所属的组织节点（可多选）以便条件搜索
4. 数据对象可以设置组织节点对自己的操作权限（可多选）以便控制读写

### 组织结构的定义

```js
{
  type: "G",
  name: "我的公司",
  children: [
    {
      id: "DA",             // 全树唯一 ID
      // 节点类型：G-分组,P-职位
      type: "G",            // 节点类型
      icon: "fas-xxx",      // 节点图标
      name: "Dept A",       // 节点名称
      children: [
        {
          id: "DA1",
          type: "G", 
          icon: "fas-xxx",
          name: "WGroup 1",
          children: [
            {
              id: "DA1M",
              type: "P",
              icon: "fas-xxx",
              name: "Manager"
            }
          ]
        },
        {
          id: "DA2",
          type: "G", 
          icon: "fas-xxx",
          name: "WGroup 2"
        },
      ]
    }
  ]
}
```

### 用户选择自己所在组织节点

```js
{
  ...
  // 用户通过这个字段，关联自己所在的部门以及职位
  // 这里只是记录了职位的列表，虽然可以多选，但是通常只有一个
  // 职位所在的上级部门也自动成为了用户的所属部门
  // 这样，在对象处，可以用高层的部门或者最低一层的职位指定所属权限
  positions: ["DA1M"]
  ...
}
```

当用户（域内用户）登录后，根据登录站点的 `organizition` 属性，可以得到一个组织结构表。
通过用户的 `positions` 可以得到所属职位。结合两者，可以得到一个用户所在组织节点的列表。
譬如， `DA1M` 展开，可能就是:

```js
["DA", "DA1", "DA1M"]
```

这个信息会保存在用户的会话里，作为一个只读属性。
这样，无论前端还是后端，都可以里用这个列表进行一些暗戳戳的操作。

### 对象中设置所属部门

```js
{
  ...
  // 属于多个部门或者工作组甚至职位，这样在条件查询时，翻页将
  // 不会有页空白
  belong : ["DA","DB2"],
  pvg: {
    // 加号开头的表示组织权限
    "+DA" : "0755",
    "+DA1M" : "0777":
  }
}
```

## 主目录访问权限

如果想让某个域内账户用系统会话登录域，那么需要让其至少可以访问主目录。
有四种办法：

1. 直接添加权限： `pvg: {UID: 511}`
2. 添加用户某个角色 `pvg: {@user: 511}`
3. 添加其他角色 `pvg: {@others: 511}`，这会导致所有人都有访问主目录权限
4. 将用户或者其某个角色设置为 `roleInDomain:10` 表示这个用户为主组成员

--------------------------------------
# 数据接口

--------------------------------------
## `/a/auth_login_by_domain_ticket`自动登录系统会话

### 请求头

```bash
HTTP GET /a/auth_by_domain
#---------------------------------
# Query String
ticket : "34t6..8aq1"     # 【必】登录会话的票据
site   : "34t6..8aq1"     # 【选】站点的ID，如果不提供，采用host寻找
```

### 响应成功(HTTP 302)

```js
{
  ok : true,
  data : {
    /*请参考《基础账户授权模型》会话数据结构*/
  }
}
```

### 响应失败(HTTP 400)

```js
{
  ok : false,
  errCode : "e.auth.ticked.noexist",
  msg : "xxx"
}
```
其中 `errCode` 可能的值包括：

- `e.www.api.auth.nologin` : 未指定会话票据
- `e.auth.ticked.noexist` : 会话票据不存在


### 初始化脚本

> 内置 API　无需初始化脚本

--------------------------------------
# 使用方式

1. 用户打开自定义的站点界面譬如 `www.demo.io` 
  + 界面显示登录对话框
2. 用户登录成功后（站点会话）任意界面点击链接 `/a/auth/auth_login?site=xxx&ticket=xxx`
3. 服务器会依次尝试：
  + 查找系统会话`COOKIE(SEID)`
  + 站点会话`site+ticket`，自动创建系统会话
  + 成功后返回 `OPEN` 所对应的应用
4. 登出时，会看会话的字段，如果有记录退出的环境变量`LOGOUT`则退出到这个 URL

--------------------------------------
# 相关知识点

- [基础账户授权模型][c0-bam]
- [核心会话服务][c0-css]
- [站点账户授权接口][w0-saa]

[c0-bam]: ../core-l0/c0-baice-auth-model.md
[c0-css]: ../core-l0/c0-core-session-service.md
[w0-site]: ../webs-l0/w0-site.md
[w0-saa]: ../webs-l0/w0-site-auth-api.md
