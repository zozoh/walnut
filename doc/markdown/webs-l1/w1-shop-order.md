---
title: 商城订单模型
author: zozohtnt@gmail.com
key: w1-shop-order
---

--------------------------------------
# 订单的创建过程

> 在创建真正的支付单之前的计算步骤

## 订单的输入

```js
{
  //---------------------------------
  tp: "A"          //【选】订单类型
  products : [{    //【必】订单产品
    id : ID,       //【必】商品 ID 
    amount:3       //【必】购买数量
  }],
  pay_tp : "wx.qrcode"  // 【必】支付类型
  //---------------------------------
  coupons : [{     //【选】优惠信息
    id : ID,       //【必】优惠券ID
  }]
  //---------------------------------
  // 【选】收货信息，用来计算运费
  addr_user_country : "CN",             // 国家编码，默认 CN
  addr_user_code    : "110108017000",   // 12位地址编码
  addr_user_door    : "xxx xx A-302",   // 详细到门牌的地址
  user_name  : "xxx"      // 联系人姓名
  user_phone : "139.."    // 联系人手机
  user_email : "zz@z.com" // 联系人邮箱
  //---------------------------------
  buyer_id : ID            //【自】根据会话填入
  accounts : "~/accounts"  //【自】根据站点元数据
}
```

## 计算过程

```bash
#
# 首先做一下防守检查
#
1. 必须有产品
2. 必须设定了 accounts, buyer_id

#
# 确保默认货币单位
# ??? ! 这个是不是应该强制采用站点的货币单位呢？
# ??? ! 一个站点多个结算货币，好像也不是一个好设计
#
默认用站点的货币单位，除非输入里面特别指定

#
# 检查订单类型
#
必须为 A 或者 Q ， 默认为 A

#
# 计算订单价格
#
>> 这个进入到【价格计算过程】
>> >> 这个过程也会重新加载商品，优惠券等数据，并计算运费

>> 如果计算出了问题，会抛 "e.www.order.nil_check.products"

#
# 检查订单库存，防止超卖
#
1. 通过 "skuKey" 参数来决定本订单是否需要检查库存
2. 所有有 "skuKey" 的商品，都要检查对于商品购买数据是否超卖
   + 如果超卖，就抛错 "e.www.order.OutOfStore"

#
# 根据付款类型找到销售方
#
? 如果订单设置了付款类型
  根据 payType 前缀找到 seller 并更新订单元数据

#
# 补齐商品的冗余字段
#
- proid0, proids, pro_c 等

#
# 根据付款类型 pay_tp 找到销售方
#
1. sellers 集合来自站点
>> 如果没有销售方，则抛错 "e.www.order.invalid.pay_tp"

#
# 设置其他订单字段
#
1. 默认状态为 "NW"
2. 自动设置默认标题为 seller 的名字
3. 站点如果指定了过期时间（分钟），则设置订单过期自动删除时间

#
# 持久化订单到订单库
#
通常，订单库是一个数据据 "ThingSet"

#
# 根据订单减去库存
#
1. 必须有声明 "skuKey" 参数，才能执行本操作
2. 商品库中只有声明 "skuKey" 的商品，才会被减去库存

```

--------------------------------------
# 价格计算过程

## 价格计算的结果

```js
// org.nutz.walnut.ext.www.bean.OrderPrice
{
  //--------------------------------
  // 商品列表: org.nutz.walnut.ext.www.bean.WnProduct
  products : [{
    id : ID,            // 商品 ID
    amount : 1,         // 购买数量
    //..............................
    // 显示相关
    //..............................
    title: "xxx",  // 显示标题
    cate : "xxx",  // 商品分类名称
    //..............................
    // 运费相关
    //..............................
    weight ： 4.5, // 重量（公斤）（可作为运费计算依据）
    freight : 0.0, // 固定运费（元）
    //..............................
    // 价格体系
    //..............................
    pro_id : ID,       // 价格规则对象的 ID
    price_by  : "xx",  // 价格规则名称
    pcount : 10,       // 如果设置了价格体系，那么在相同价格体系下，
                       // 所有商品购买的总数量，将会影响价格
                       // 这里则是记录一个归纳值，以便根据规则，
                       // 从价格规则表中甄选价格
    //..............................
    // 价格
    //..............................
    retail : 132.0,     // 产品标称单格（原始零售价）
    price  : 132.0,     // 产品动态单价，优先应用规则的零售价
    //..............................
    // 小计
    //..............................
    subretail : 132.0   // 小计： retail * amount
    subtotal  : 132.0   // 小计： price  * amount
  }],
  //--------------------------------
  // 运费详情 : org.nutz.walnut.ext.lbs.bean.LbsFreight
  freightDetail : {
    // 重量分析 : $Weight
    weight : {
      first : 1.5,      // 首重（公斤）
      additional : 3    // 续重（公斤）
    },
    // 相关运费计算规则 : org.nutz.walnut.ext.lbs.bean.LbsFreightRule
    rule : {
      title : "xxx",           // 规则标题，仅仅是助记用的
      ship_code   : "100100",  // 发货地（六位地址编码）
      target_code : "430010",  // 目的地址（六位地址编码）
      first : 12.0,            // 首重价格（元）
      additional : 2           // 续重价格（元/续重单位）
    },
    // 运费相关明细
    first : 12.0,            // 总首重价格（元）
    additional : 6.0,        // 总续重价格（元）
    total : 18.0             // 总运费（元）
  },
  //--------------------------------
  freight  : 12.0,     // 总运费
  total    : 500.0,    // 商品总价
  nominal  : 500.0,    // 标称总价
  profit   : 0,        // 收益金额
  prefee   : 500.0,    // 基础金额
  discount : 20.0,     // 优惠金额 (基于 prefee 应用优惠券节省的金额)
  price    : 512.0,    // 惠前金额 (prefee + freight) 
  fee      : 492.0,    // 支付金额 (price - discount)
  currency : "RMB"     // 货币单位
}
```

## 计算的过程

```bash
#
# 依次检查产品列表
#
依次检查商品列表
  > 数量小于等于 0 的项目无视
  > 重新读取价格运费等信息
  ? 如果设置了价格汇总键 `${pro_id}_${price_by}`，则汇总产品数量
    !! 注意，这里的 `pro_id` 为商品的价格规则对象的 ID，譬如`商品包`ID
如果木有商品，则返回 `null` 表示计算订单价格失败

> 将得到一个 `pcounts` 归纳表，归纳相同价格体系下商品总数量
   { [`${pro_id}_${price_by}`] : N }

#
# 计算价格
#
依次轮询商品列表中的商品，对于每个商品：
  # 确定单价
  ? 如果声明了动态价格规则
    > 从 `pcounts` 获得自己的数量
    > 从价格规则（`org.nutz.walnut.ext.www.bean.PriceRuleSet`）获取价格
    > 更新当前商品价格 `price`
  # 确定运费
  ? 如果声明了固定运费 `freight` 则
    > 汇总固定运费费用： `freight * amount`
  ? 否则汇总重量，以便稍后计算总体订单运费
    > `weight * amount`
  # 小计商品价格
  > 计算商品小计 `subtotal = price * amount`

之后能汇总订单的总价格 `total`
以及标称总价 `nominal`

#
# 决定基础价格
#
基础订单金额 `prefee` 来自站点设置 "feeMode"
  > `prefee` = `feeMode == TOTAL`
      ? `total`
      : `nominal`

#
# 计算运费
#
? 如果设置了运费表，且订单设置了收货地址
  1. 确保有发货地址，没有的话，则读取默认发货地址
  2. 查运费表得到运费规则 `LbsFreightRule`
     > 这里，为了测试方便，会把运费规则也附加到最终结果里
  3. 根据首重续重等，计算运费价格
     > 这里，为了测试方便，会把计算的结果细节也附加到最终结果里

#
# 优惠与折扣
#
> 基于 `basePrice` 进行优惠
? 如果订单设置了优惠券
  > 依次检查每张优惠券：
    1. 从数据库里读取一遍
    2. 不符合应用条件的优惠券则被跳过
    3. 叠加应用优惠券
> 最终得到订单实际支付金额 `fee`

#
# 得到总折扣信息以及支付信息
#
- 总运费   : `freight += fixFreight`
-
- 商品总价 : `total` 即采用价格规则优惠后的价格
- 标称总价 : `nominal` 即商品 price 字段的原始汇总的价格
- 收益金额 : `profit = nominal - total`
-
- 基础金额 : `prefee = $total or $nominal` 
-
- 总折扣   : `discount` : (基于 `prefee` 应用优惠券节省的金额)
- 惠前金额 : `price = prefee + freight`
- 支付金额 : `fee = price - discount`
-
!
! 所有的价格对齐到`分`，四舍五入
! 运费则对齐到`元`，四舍五入
!

#
# 最后将上述信息计入返回结果
#
> org.nutz.walnut.ext.www.bean.OrderPrice
```
