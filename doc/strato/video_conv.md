---
title: 视频转换
author: pw
---

# 转换规则

* 支持修改分辨率
* 支持切割转换, 即将视频转换成NxM份


# 存放规则

```
$HOME/.video_conv/
	489A3.... 				# 视频文件的sha1
		1920x1080_1x1		# 转换目录, 命名方式为 "分辨率_分割大小"
			1_1.mp4
		1920x1080_2x2		
			1_1.mp4
			1_2.mp4
			2_1.mp4
			2_2.mp4
		640x480_1x2
			1_1.mp4
			1_2.mp4
	3DA99....
		1280x768_1x1
			1_1.mp4
```

# 转换流程

v_ 代表video相关
vc_ 代表video_conv相关

1. 上传视频, 生成obj对象
2. 读取文件, obj添加如下meta属性
	```
	{
		v_width: 1920,			# 视频原始宽度
		v_height: 1080,			# 视频原始高度
		v_length: 12.2 			# 视频长度(秒)
	}
	```
3. 使用默认转换参数, 生成原视频比例, 1x1大小的转换视频
4. 手动指定准换参数, 生成指定分辨率, 分割大小的转换视频
5. 3,4步骤将并不直接调用转换命令, 而是向转换队列中添加一条转换请求, 同时向obj添加如下meta属性
	```
	{
		vc_state : "queue",		# 转换状态 queue (排队) > ing(转换中) > done(转换完毕) or fail (转换失败)
		vc_width : 1920,		# 转换后总宽度
		vc_height: 1080,		# 转换后总高度
		vc_x: 2,				# 水平切割份数
		vc_y: 3,				# 垂直切割份数
		vc_fail: "",			# 转换失败的log信息
		vc_path: ""				# 转换文件所在目录
 	}
	```
6. 视频开始转换, 判断是否是已经转换过的视频, 更新obj的meta信息. 调用转换命令
	```
	{
		vc_state : "ing"		# ing(转换中)
 	}
	```
7. 当视频转换完毕, 更新转换队列状态, 更新obj的meta信息
	```
	{
		vc_state : "done",		# done(转换完成)
		vc_fail: "",			# 转换失败的log信息, 如果state是fail的填写
		vc_path: "/root/.video_conv/489A3..../1920x1080_2x3"	# 转换文件所在目录
 	}
	```

其中第6步, 如果发现已经存在了转换好的视频, 则直接更新obj的meta信息. 


# 转换队列

因为视频只能一个一个转换, 所以要进行排队, 同时记录文件的转换结果

{
	src: "/root/video/xxx.avi", 		# 原始文件的path
	oid: "39A99133....",				# obj对象的id,
	sha1: "489A3....",					# sha1
	usr: "root",						# 转换的用户
	width: 1920,						# 转换后宽度
	height: 1080,						# 转换后高度
	x: 2,								# 水平分割份数
	y: 3,								# 垂直分割份数
	state: "queue",						# 当前状态,
	fail: "",							# 失败信息
	ct: "2015-07-15 14:32:44.555"		# 创建时间,
	dt: "",								# 完成时间
}

