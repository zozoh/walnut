---
title:对象存储策略
author:zozoh
---

# 对象存储类型

本文并不讨论对象存储的具体实现，相反它是对对象存储实现的一个概念性参考。
对于一个对象，如果要将其内容持久化，到底有哪些方式，以及各有什么特点

一个对象的内容一旦被创建，考虑到后续可能被读写的具体应用场景，可以有下面的几类：

|  Type    | Mass  | R | A | W | SR| MA| MW|
|----------|-------|---|---|---|---|---|---|
| Log      | Huge  | + |`+`|*.*|`+`|`+`|*.*|
| Video    | Huge  | + |*.*|*.*|*.*|*.*|*.*|
| Photo    | Big   | + |*.*|*.*|*.*|*.*|*.*|
| Text     | Small | + |*.*|`+`| + |*.*|*.*|
| Conf     | Tiny  |`+`|*.*| + |*.*|*.*|*.*|
| Swap     | Big   |*.*|*.*|*.*|`+`|*.*|`+`|

# 一些思考

思考的结论：

* 一个对象只能有一个写句柄，多个写句柄只有 SA 的情况。 
* 一个句柄最多只能有一个缓冲，缓冲的 ID 就是句柄 ID
* 因此，SA 可以并行，W 不行, 因此不应该有 SW

如果是像快照类的场景
> 一个程序猛写，因为写就是在缓冲区里追加，另外一堆程序猛 R 即可
> 直到 flush 另外一堆程序才能看到结果，并且这个结果是有历史记录的

如果是日志的 tail -f 场景 
> 几个程序相继向缓冲区里追加，另外的程序们 SR 即可。 SR 的时候会记录
> 观察者，那么每次缓冲区写，都会 tell 他们

如果是 watch 命令的场景
> 一个程序 W，另外几个SR，因为是 SR，那么会被添加 observer 到自己的
> 句柄，每次缓冲区被 write, flush, close 都会通知回自己的句柄
> 
> 实际上 observer 管理器应该变成全局锁管理器
> 负责资源同步和通知


如果是图片，视频等较大数据的读写场景
> 那么通常都是 W，同时其他人只能 R。
> W，也就是说把缓冲区当做流，持续追加

因此 ZIoObjStore 提供 

    alloc(key)   针对一个文件句柄开辟缓冲区，如果已开了，抛错
    free(key)    则表示释放这个缓冲区
    read/write   都针对这个key
    clear(key)   则清空缓冲区
    persist(key): sha1
    persistRead(key) 则从固化的内容里直接读取

对于 Obj
> 一旦用 W、A、SA 方式打开了，则会将句柄记录到 Obj 的 "hdl" 字段里。
> 以便后续的的 open 操作正确抛出异常，或者共享缓冲区

读写共享
> 如果 W、A、SA 后，几个程序以 SR 方式共享查看缓冲区，那么如果 W 关了。
> SR 们因为 rpos 的存在，则会完全透明

对于 IoMode 还应该有 RW 和 RA
> 这样同样的句柄还能用来读取





