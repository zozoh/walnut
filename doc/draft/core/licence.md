---
title:许可证机制
author:zozoh
tags:
- 系统
- 支付
- 许可证
---


# 什么是许可证

在 walnut 上，从服务提供的角度，可以有下面三种角色

1. 系统 (walnut)
2. 服务提供方
3. 使用者

所谓许可证，就是服务提供方在自己的域构建一系列许可证数据，包括各种自定义的权限字段。使用者通过服务提供方的服务，将一个激活码保存到自己的域中，从而享有许可证允许的权限。

服务提供方在自己的提供的 app 里面也对使用者的许可证进行验证

如果对方的许可证激活码到期，服务提供方可以拒绝服务。当然用户可以用系统提供的免费应用浏览管理自己的数据，比如 `wn.console` 比如 `wn.browser`

# 为什么要有许可证

在用户与权限中，系统提供了类似 `Linux/Unix` 的方式，对于文件/目录对象做了权限划分，以保证系统用户域的数据安全性。

对于应用编写者来说，光有这个功能还不够，他们还需要更灵活的设定，来设定某个应用在自己的应用里能做的事情。可以这么说:

1. 权限体系针对的是数据，而不是程序
2. 许可证体系针对的是程序，而不是数据

系统提供了通用的许可证体系，任何应用的开发者都可以得到充分的支持，发放自己的许可证，同时关联到到系统的支付体系，许可证可以很方便的支持售卖。应用开发者很容易就能提供一个付费+免费应用，只要应用做的吸引人，他就能得到很好的收入。

# 许可证的数据结构

```
/app
    wn.hmaker            # 某个应用
        app_licence      # 本应用需要的许可证信息，没有这个文件则表示可以任意使用        
/home
    redfox                # 服务提供商域
        .licence          # 存放所有的公开许可证
            abc.licence   # 某一个许可证，可以随意命名
            bbc.licence   # 另外一个许可证
        .acode            # 存放许可证的激活码
            $ID1.acode    # 激活码就是一个 UUID
            $ID2.acode    # 激活码有很多
    xiaobai               # 使用者
        .app_licence      # 存放使用者得到的许可证激活码
            wn.hmaker.code     # 一个应用只能有一份许可证
            wn.ztask.code      # 使用者可以拥有多个不同应用
```

## 文件 app\_licence

JSON 文件内容

```
{
    // 对应的应用名称
    appName : "abc",
    
    // 哪个域可以发放本应用的许可证
    provider : "DomainName1",
    
    // 是否支持自动发放体验版许可证
    autoGenCode : {
        day     : 30,     // 有效期（天），0 表示不限时
        licence : "abc"   // 对应许可证
    }
}
```

## 文件 .licence

```
{
    // 许可证识别名
    name : "xxx_home_edition",
    
    // 签发日期
    signDate : "2016-09-21 12:33:24"
    
    // 所属组织
    belongTo : "providerDomainName"
      
    // 考虑到有些许可证，可能是需要动态判断用户的状态的，比如是否有充足的余额等
    // 因此可以给出这个字段来动态检查用户域的状态。
    // 自动执行命令，如果有这个字段的许可证，会执行一个用户自定义命令
    // 命令会的错误输出流可以有下面的值（区分大小写）:
    //  ok                  - 给定域具备使用这个许可证的前提条件
    //  e.licence.nsf       - 账号余额不足
    //  e.licence.out_of_bf - 流量用尽
    //  e.licence.out_of_ds - 磁盘空间不足
    //  e.licence.out_of_rn - 请求数量超过限制
    //  e.licence.busy      - 没有足够的计算资源
    //  e.licence.block     - 因违反规定而被限制访问
    //  e.licence.forbiden  - 域账号不符合本许可证的使用条件
    //  其他任意字符串均表示验证失败的原因
    // 如果错误输出流没有内容，则表示验证通过
    // 权限是当前操作账号权限
    verify : "cmdText",

    // 用户可以对应有有哪些特权, 原则上就是一组名值对
    // 这个字段的值会传递给应用界面，由应用界面来理解具体含义
    privilege : {...}
}
```

## 文件 .acode

无内容，仅有元数据

```
id         : "xxx"        // 唯一标识符
//.............................................
ac_day     : 0            // 有效天数
ac_licence : "abc"        // 对应本域的哪个许可证
ac_app     : "wn.hmaker"  // 对应哪个 app
ac_expi    : AMS          // 激活码过期时间，0 表示永不过期
//.............................................
// 激活码类型
//  auto - 自动生成
//  gen  - 手动生成
ac_tp      : "auto|gen"
//.............................................
// 用户信息
ow_dmn_id  : ID        // 服务商域 ID
ow_dmn_nm  : xxx       // 服务商域 nm，必须与 ow_dmn_id 匹配
buyer_id   : ID        // 购买者 ID，
buyer_nm   : xxx       // 购买者 nm，必须与 buyer_id 匹配
ct         : MS        // 创建时间
use_time   : MS        // 生效时间
```

## 文件 .code

普通文件而已，内容是 acode 文件的 ID。当然，其有效性是根据 App 里面的 `app_licence` 文件的限制来的，具体如何限制，请参见下文

# 许可证验证的流程

```
用户打开 App 
//............................................. 验证许可证
查看 app_licence 文件，如果存在则需要进入 licence 验证逻辑
{
    根据当前操作的用户（用户的主域）得到 .app_licence 下面本应用的激活码 
    如果不存在激活码 {
        直接去服务商域查找 acode 记录
        如果记录存在且有效 {
            为当前用户生成激活码文件
        }
    } 否则 {
        根据激活码找到服务商的 acode 记录
    }
    
    如果找到了激活码，则验证激活码的有效性 {
        1. 属于当前用户的
        2. 没有过期的
    } 否则 {
        相当于没找到合法 licence，本逻辑戛然而止
    }
    
    根据这个有效的激活码，得到对应的 licence 文件内容
    并将这个文件的内容解析成 JSON 对象
}
//............................................. 得到了许可证
如果需要 licence {
    如果没有找到合法的 licence 文件
    {
        重定向到激活码输入页面，页面包括
        1. 激活码输入界面
        2. 如果 app 允许自动生成激活码，则显示免费体验 xxx 天的链接
            
    } 否则 {
        将得到的 licence 信息计入页面的的 app.licence 对象里
    }
}
//............................................. 许可证验证结束
执行 App 应用的后续操作
```

* `WnLicenceService` 将封装这个验证流程的核心逻辑
* `AppModule` 将针对每个 App 的打开，执行这个逻辑
* `cmd_licence` 将封装这个流程，以便测试

# 任何一个 UI 的许可证权限

一个 APP 由很多 UI 构成，每个 UI 可以被任意编写。 UI 的编写者可以主动读取许可证信息，
并读取其中自己需要的字段，来决定自己的具体用户交互行为

