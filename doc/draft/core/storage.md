---
title: 数据存储
author: zozoh
tags:
- 系统
- 数据存储
---

# 多样化的数据存储

1. 系统底层认为每个 *WnObj* 都可以有一个存储
2. 存储被认为是一个接口
3. 一个对象的数据应该可以被散列到不同的物理机上

# 存储句柄

```
id                # 句柄的唯一标识，一个 UUID32 字符串
ct                # 句柄创建的时间（绝对毫秒数）
lm                # 句柄最后一次被访问的时间（绝对毫秒数）
mode = R|W|A|RW   # 句柄打开类型

obj  -> {..}      # 对象的索引
pos = 0           # 文件对象读写位置指针 
swap              # 指向一个字节数组作为写操作的缓冲
                  # 缓冲的大小与桶的块大小一致，或者是整数倍
                  # 如果缓冲满了就向桶中加入一个块
                  # 如果文件的随机访问，也同时要考虑到桶的 padding
swap_size         # 缓冲区有效数据长度

bucket            # 指向一个数据桶的 ID，读写操作都是针对这个桶的
                  # 如果关闭句柄，如果是写操作，自然会将这个桶的 ID 更新
                  # 到 obj.data 字段里
```

# 数据桶

```
id                # 桶的唯一标识，一个 UUID32 字符串
sealed            # 桶是否设成只读
sha1              # 桶内有效数据的 SHA1 指纹
len               # 桶的有效数据总长度

ct                # 桶被创建的时间（绝对毫秒数）
lm                # 桶被最后修改的时间，新桶，等于 ct
lread             # 桶被最后读取的时间
lwrite            # 桶被最后被写入的时间
lseal             # 桶被最后被盖上的时间
lopen             # 桶被最后被打开的时间，新桶，等于 ct

refer_count       # 桶的引用计数
read_count        # 桶历史被读取的次数

block_size        # 桶的数据块大小
block_nb          # 桶的数据块数量，一个桶逻辑空间大小应该是 block_size * block_nb

fromBucketId      # 如果桶是复制出来的，这里给出原桶的 ID
```

1. 数据桶存放尺寸大小一致的数据块
2. 当数据桶被盖上后，会生成一个 sha1 表示自身全部数据的指纹
3. 对象的数据桶如果只读，写入数据时，会新分配一个数据桶给它，旧的桶会被回收
4. `sealed && sha1` 的桶，会根据 *SHA1* 去掉重复
5. 可以根据 *SHA1* 来寻找一个数据桶

# 将桶存放在本地磁盘

```
$BUCKET_HOME
    23
        45cda3f..           # 某一个桶的目录
            bucket.json     # 桶的信息数据
            0               # 桶的第 0 个数据块
            1               # 桶的第 1 个数据块
            ...
```

* 系统启动只会检查 `$BUCKET_HOME` 是否存在
* 当调用者想读取一个桶信息，系统会首先检查内存缓存，如果有，就使用，否则就试图从磁盘加载
* 系统最多缓冲多少个桶信息，这个需要看配置项，默认不限
* 当调用修改桶的数据，桶的信息是否会立即存入磁盘，以及存入磁盘的时机由实现者掌握

# 桶接口

```
sha1(gen)  : 获取桶的数据指纹，gen 表示如果没生成过，是否立即生成 sha1
#..........................................
# 读取桶的一部分数据
read(long pos, byte[] bs):int
read(long pos, byte[] bs, int off, int len):int
#..........................................
# 写入桶
write(long pos, byte[] bs)
write(long pos, byte[] bs, int off, int len)
#..........................................
# 封装桶，封装成功，返回桶数据的 SHA1
# 桶被封装的时候，会根据内容自动调整自己的桶块大小
# 桶块的大小是 8192(8K) 的倍数，以便最大限度提供桶的读取效率
seal()    : SHA1
unseal()  : 
#..........................................
duplicate() : WnBucket     # 复制一个桶
refer() : refer_count      # 引用一个桶，返回引用后的计数
```

# 桶管理器

```
alloc(blockSize) : Bucket  # 分配一个新桶，blockSize 表示数据块的大小
free(buid)       : Bucket  # 释放一个桶，会减少桶的引用计数，如果为0，则释放桶
getById(buid)    : Bucket  # 获得一个桶
checkById(buid)  : Bucket  # 获得一个桶，不存在即抛错
getBySha1(sha1)  : Bucket  # 根据 sha1 获得一个桶
checkBySha1(sha1): Bucket  # 根据 sha1 获得一个桶，不存在即抛错
```

# WnStore & WnStoreFactory

存储接口的实现有两种

1. 将对象存成本地文件，即某个节点完全映射到一个本地目录
2. 将对象存储成桶

# 桶的封盖策略

```
/---\       /...\       /...\
| A |       .   .       .   .
\---/ <---- +---+       .   .
            | B |       .   .
            \---/ <---- +---+
                        | C |
                        \---/
```

## 什么时候复制桶

* 桶一旦封盖就立即是只读的，不能解封
    - 除非桶只有一个对象在使用(`refer==1`)，则可以重新打开这个桶对象继续写
    - 写入封盖的桶，会创建一个新桶，用 `parentBucketId` 指向原桶
* 追加写入的话，原桶的最后一块没满，那么会复制一份作为本桶的第一块
    - 当然如果原桶只有一块，那么本桶将作为独立桶
* 因此还是有可能造成上图的结构，形成一个桶链
    - 作为桶链的末端，如果在虚空间写入块，会造成封盖时将之前所有的桶块 copy 过来
    - 那么这个桶就脱离了桶链成为一个独立的桶

## SHA1 去重

* 关闭写句柄，会导致桶被封盖
* 当桶被封盖后，会记录一个封盖时间，并生成 sha1 指纹
    - 封盖的时候，总是会标记 `nodup=true`
* 等到桶冷却了（封盖时间过了一段时间后），会对这些冷却的桶进行指纹去重
    - 依次遍历冷却的桶(未去重 `nodup=true`)
    - 从这些桶的指纹指纹找有没有其他的 `nodup=false` 的桶
    - 如果有，将这个桶对应的对象们指向那个桶，然后释放原来的桶
    - 冷却时间通常为 10 分钟
    - 去重完毕，设置 `nodup=false`












