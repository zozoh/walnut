# 需要考虑的问题

- 内部窗口拖动，能不能在外部窗口用遮罩捕获时间
- 截获并模拟双击事件
- 辅助线用 canvas 来绘制效率如何
- 放置到拖拽目标里，应该用交集面积大于自己面积的一半(可配置)来决定
- 配置对象给出生成拖拽目标的矩形数据
    + 必须相对于全局 window
    + 包括 jQuery 对象，以及一个 Rect
    + 如果给出的是一个 jQuery，则会自动计算 Rect
- 预处理鼠标位置方式
    + 自由
    + 仅横轴
    + 仅纵轴
    + 固定区域
    + 网格
    + 磁力网格
- 移动回调函数，可以决定 mask.trigger 是否跟着移动 
- 如果没有 findTarget，那么 this 就是 target

# 已经确定了拖拽相关的问题

## 启用

- 考虑到绘制的自由度， *mask* 还是固定是加在顶级 *window* 比较好
- 比较友好的还是用 `mousedown` 启用
- 如果 `mousedown` 了，只能在同级窗口捕获 `mouseup`
    - 即不要指望在 *mask* 截获 `mouseup` 事件

## 注销

- 在原对象所在的窗口上监听 *mouseup* 一定可以得到的

# 浏览器兼容性

```
Safari:
 - 内部 window 的 "mousemove" 事件，如果窗口滚动下去，就截获不到了
 - Safari 的确傻逼
```

# 遮罩层的逻辑

```
window
    iframe
        document.body
            某拖拽目标
    DIV.z-moving-mask
        DIV.z-mvm-viewport      <!--// 视口副本-->
            DIV.z-mvm-sit       <!--// 在视口内的可见感应器 -->
                SECTION         <!--// 感应器的可见部分包裹容器 -->
        DIV.z-mvm-sensors       <!--// 感应器绘制层-->
            DIV.z-mvm-sit       <!--// 在视口外的可见感应器 -->
                SECTION         <!--// 感应器的可见部分包裹容器 -->
        DIV.z-mvm-target        <!--// 移动目标的显示副本-->
        CANVAS.z-mvm-assline    <!--// 辅助线绘制层-->
```

# 几个概念

*moving* 插件实际上是：在指定`选区(selection)`监控`触发器(trigger)`的*mousedown*事件。
一旦触发，寻找移动的`目标(target)`，并监视其再`视口(viewport)` 里的移动。

移动的时候，插件会在顶级窗口准备`遮罩(mask)`元素，并在其内监控`感应器(sensor)`对应的行为，并根据配置，动态的绘制辅助线。

- `可视区域(client)`即浏览器窗口所在的区域，移动的所有位置计算都是相对这个区域的
- `选区(selection)`就是插件的 *this*
- `触发器(trigger)`声明了*选区*内可以被触发的元素选择器，默认为 `> *`
    - 插件会用`$(selection).on("mousedown", trigger, F())`来触发
- `目标(target)`得到*触发器*后，会在触发器里查找真正的拖拽目标，默认为*触发器*本身
- `视口(viewport)`得到*目标*后，查找自己的视口，默认为*选区*
- `感应器(sensor)`会在鼠标经过后触发指定操作。默认感应器有
    - `scroll-N` :  向上滚动(优先)
    - `scroll-S` :  向下滚动(优先)
    - `scroll-W` :  向左滚动
    - `scroll-E` :  向右滚动
- 调用者可以自行添加更多的感应器，比如添加*drop*的目标等
- `遮罩(mask)`为拖拽时动态绘制的元素的父元素，拥有比较高的*z-index*，它覆盖整个*可视区域(client)*


# 运行时上下文

在插件被触发会创建如下的`上下文对象(MVing)`:

```
Event   : Event,       // 事件对象
options : {..},        // 插件的配置信息
win     : Window,      // 选区所在的窗口
doc     : Element,     // 选区所在文档对象
body    : Element,     // 选区所在文档对象的 Body 元素
$body   : jQuery,      // 选区所在文档对象的 Body 元素 jQuery 包裹
$selection : jQuery,   // 选区的 jQuery 对象
$trigger   : jQuery,   // 触发器的 jQuery 对象
data : ..              // 来着 options.data
//..................................................
$viewport  : jQuery,   // 视口的 jQuery 对象
$target    : jQuery,   // 移动目标的 jQuery 对象
//..................................................
// 视口初始的滚动补偿
// 这个会影响对于视口内感应器的匹配
viewportScroll : {
    x : 0,       // x 轴，即 scrollLeft
    y  : 0       // y 轴，即 scrollTop
},
//..................................................
// 初始点击位置信息
posAt : {
    target   : {x,y},      // 相对于目标
    client   : {x,y},      // 相对于可视区域
    viewport : {x,y},      // 相对于视口
},
//..................................................
startInMs : MS,       // 开始时间
//--------------------------------------------------
// 以下为真正触发移动后创建的属性
//--------------------------------------------------
endInMs   : MS,       // 结束时间（有了结束时间表示移动结束了）
//..................................................
// 指针位置
cursor : {
    client   : {x,y}   // 相对于可视区域
    viewport : {x,y}   // 相对于视口
    delta    : {x,y}   // 相对于上次位置的位移
    offset   : {x,y}   // 相对于初始点击位置
                       // 即 cursor.client - posAt.client
},
//..................................................
// 移动方向
direction : {
    x : "left" | "right" | null,
    y : "up"   | "down"  | null
}
//..................................................
// 矩形信息
// 如果参数给定了 viewportRect，那么所有的矩形队友对其进行转换
// 即，如果是一个 iframe 内的网页，且 mask 默认是附加在顶级窗口对象上的
// 则需要制定 viewportRect，那么这组矩形信息都是相对于顶级窗口的
rect : {
    viewport : Rect,      // 视口
    target   : Rect,      // 原始目标
    current  : Rect,      // 目标当前跟随移动所应该的设置的矩形
},
//..................................................
// 根据目标矩形，计算出一个矩形，并用这个矩形来限制目标边界
// 返回 null 或者没有这个函数定义都表示不限制
boundaryBy : {c}F(targetRect):Rect
//..................................................
// 计算当前目标和视口的关系
css : {
    rect    : Rect,     // 目标当前相对于视口的位置信息
                        // 补偿了视口的 scrollTop/Left
    current : {..},     // 给出 css 描述，默认 top,left
                        // 配置项 cssBy 指定了要获取哪些属性
},
//..................................................
// 遮罩层的其他绘制层
$mask      : jQuery,   // 遮罩的 jQuery 对象
mask : {
    $viewport : jQuery,    // 视口副本 
    $sensors  : jQuery,    // 视口外可见感应器绘制层
    $target   : jQuery,    // 移动目标副本
    $assline  : jQuery,    // 辅助线绘制层
    G2Dass    : Graphic2D  // 辅助线图形绘制接口
}
//..................................................
// 感应区，数组按顺序匹配。遇到匹配的感应区则停止
// 因此靠前的感应区优先级比较高
sensors : [{
    name    : "xxx",     // 感应器名称，插件会在 sensorFunc 里执行对应的匹配方法
    text    : "xxx",     // 可见感应器，显示文字
    rect    : Rect,      // 感应区范围
    $ele    : jQuery,    // 感应区对应的元素。可以为 null
    $helper : jQuery,    // 可见感应器对应的显示元素。即 DIV.z-mvm-sit
                         // 不可见的感应器，此项为 null
    inViewport : false,  // 是否在视口内，且随视口一起滚动
    visibility : false,  // 是否要在绘制层显示感应区
    matchBreak : true,   // 如果匹配上了，是否继续匹配后续感应器，默认 true
}],
// 感应器如果匹配上了，根据名称，执行集合中的函数
// 如果没有对应的函数，则会抛错
// 一个感应器函数必须有两个方法 
//   "enter" 表示进入感应器 
//   "leave" 表示离开感应器
// 每个方法都接受下列相同的参数
//  - {c}    : 为上下文对象本身
//  - sensor : 为感应器对象本身
//  - index  : 为感应器下标
sensorFunc : {
    "xxx" : {
        "enter" : {c}F(sensor, index),
        "leave" : {c}F(sensor, index),
    }
    ...
}
```

> 这个上下文对象存放在 `window.__nutz_moving`，当移动完成后会被自动销毁

# 如何创建

```
$(ele).moving({
    //..................................................
    // 表示鼠标移动多少像素才会真正触发移动
    // 默认 3 像素
    fireRedius : 3
    //..................................................
    // 在选区之内哪些元素会触发插件
    // $(selection).on("mousedown", trigger, F())
    // 默认，会是 ">*"
    trigger  : "selector",
    
    // 查找视口，如果返回 null 或者一个空 jQuery 集合，那么表示禁止触发
    // 如果返回的是 window/document/body 任何一个元素，都表示整个文档窗口为
    // 视口，如果是内联文档，通常会指定 iframe 为视口
    // 如果未定义，则将当前选区作为视口
    viewport : jQuery | {c}F():jViewport,
    
    // 指定视口的矩形，如果有视口该选项生效
    // 默认的，插件会自动根据 viewport 来寻找视口
    viewportRect : Rect | {c}F():Rect
    
    // 有可能是 trigger 选择器内部某个元素（比如修改大小的手柄）被作为触发对象
    // 可以通过一个自定义函数，返回你确定要移动的元素。
    // 默认的，会认为整个 trigger 元素就是要移动的对象
    // 如果函数返回 null 或者一个空 jQuery 集合，那么表示禁止触发
    target : jQuery | {c}F():jTarget
    //..................................................
    // 在上下文中记录一个你自定义的对象
    // 在任何回调函数中（由于this都是 你可以直接从 MVing.data 获取你设置的值)
    // 这个值可以是一个函数，在插件真正进入移动时前，会调用，以便获取真正的数据对象 
    data : null | {c}F():Object,
    //..................................................
    // 建立的遮罩层 z-index，默认为 999999
    maskZIndex : 999999,
    
    // 为 $mask 附加类选择器，默认 null 不加
    maskClass : null,
    //..................................................
    // 滚动感应器
    // 它会创建一组最优先的感应器
    // null 表示不设置感应器
    // 默认为 {x:30, y:30}
    scrollSensor : {
        x : "10%",
        y : 30
    },
    
    // 滚动的步长，默认为 10
    // 这个值会被取绝对值，如果为0 则会被设置成默认值，即 0
    scrollStep : 10,
    
    // 滚动的时间间隔（毫秒），默认 50
    scrollInterval : 50,
    
    // 自定义感应器，函数返回一个感应器对象数组
    // 感应器对象参见 MVing 一节关于 sensors 的描述
    sensors : Sensor[] | {c}F():Sensor[..],
    
    // 感应器所使用的函数，参见 MVing 一节关于 sensorFunc 的描述
    sensorFunc : {
        "xxx" : {
            "enter" : {c}F(),
            "leave" : {c}F(),
        }
    },
    //..................................................
    // 自动修改 trigger 的位置时，采用哪个顶点
    // "top,left"      - 左上顶点
    // "top,right"     - 右上顶点
    // "bottom,left"   - 左下顶点
    // "bottom,right"  - 右下顶点
    //  null 表示不自动更新
    // 可以是数组模式，即 "top,left" 与 ["top","left"] 等价
    // 如果是拖拽模式，默认为 null
    // 否则默认为 "top,left"
    cssBy : "top,left"
    //..................................................
    // 移动的方式
    //   x : 只能横向移动
    //   y : 只能纵向移动
    //   默认为否， 即两个方向都能移动
    mode : "x" | "y" | undefined
    //..................................................
    // 如何判断 target 超出了 viewport
    // undefined : 表示不限制
    // 0 : 根据中心点
    // "100%" or Float : 为 trigger 尺寸（不包括外边距）的倍数
    // INT : 在当前宽高基础上，修改尺寸
    // 也可以是一个自定义函数，返回 target 用来限制边界的矩形
    // 如果返回`否`则表示不限制
    boundaryBy : 0 | Float | undefined | {c}F():Rect
    
    //..................................................
    // 全局回调函数
    on_begin  : {c}F()  // 移动开始时
    on_ing    : {c}F()  // 移动时
    on_end    : {c}F()  // 移动结束时
});
```

